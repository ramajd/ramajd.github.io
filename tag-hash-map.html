<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://ramajd.github.io/rss.xml"
      title="RSS feed for https://ramajd.github.io/">
<title>My Personal Notes</title>

<meta name="author" content="Reza Alizadeh Majd">
<meta name="referrer" content="no-referrer">
<link href="/static/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="/static/favicon.png"></head>
<body>
<div id="preamble" class="status">
<div class="header">
  <h1><a href="/">My Personal Notes</a></h1>
  <ul>
    <li><a href="/">Blog</a>
    <li><a href="/about.html">About</a>
  </ul>
</div></div>
<div id="content">
<h1 class="title">Posts tagged "hash-map":</h1>
<div class="post-date">16 Feb 2023</div><h1 class="post-title"><a href="https://ramajd.github.io/2023-02-23-hash-maps-in-c.html">Hash Maps in C</a></h1>

<div id="outline-container-org2a3a50e" class="outline-2">
<h2 id="org2a3a50e">About HashMap data structure</h2>
<div class="outline-text-2" id="text-org2a3a50e">
<p>
<code>HashMap</code> is a data structure which is efficient for lookup
operations. <code>HashMap</code> does the key search operation in <code>O(1)</code>.
</p>
</div>

<div id="outline-container-org334c8b8" class="outline-3">
<h3 id="org334c8b8">Strengths:</h3>
<div class="outline-text-3" id="text-org334c8b8">
<ul class="org-ul">
<li><b>Fast lookups</b>: since the <code>HashMap</code> performs the lookup operation in <code>O(1)</code>,
it's efficient for the usecases we want to continously perform the search
operations on a series of data.</li>
<li><b>Flexible Keys</b>: any comparable data type can be used as the key for <code>HashMap</code>.</li>
</ul>
</div>
</div>

<div id="outline-container-org448e55c" class="outline-3">
<h3 id="org448e55c">Weaknesses:</h3>
<div class="outline-text-3" id="text-org448e55c">
<ul class="org-ul">
<li><b>Slow worst-case lookup</b>: in the worst case which the Hash function generate
similar hash for the keys, the Lookup operation turns into <code>O(n)</code>, which is
similar to the array or linked-list.</li>
<li><b>Unordered</b>: the keys wont save in any special order, so if we want to look
for the greatest/lowest keys, we need to traverse all the keys to find the
desired one.</li>
<li><b>one-direction lookup</b>: since we can look for the value of a key in
<code>O(1)</code>, looking for the keys pointing to a specific value, requires to loop
over all the elements in the <code>HashMap</code> with <code>O(n)</code> order.</li>
<li><b>not cache friendly</b>: since most of the <code>HashMap</code> implementations are based on
<code>LinkedList</code>, we can't read a series of data together at once from the memory.</li>
</ul>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-center">

<col  class="org-center">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-center">Average</th>
<th scope="col" class="org-center">Worst Case</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Space complexity</td>
<td class="org-center">O(n)</td>
<td class="org-center">O(n)</td>
</tr>

<tr>
<td class="org-left">Insertion time</td>
<td class="org-center">O(1)</td>
<td class="org-center">O(n)</td>
</tr>

<tr>
<td class="org-left">Lookup time</td>
<td class="org-center">O(1)</td>
<td class="org-center">O(n)</td>
</tr>

<tr>
<td class="org-left">Deletion time</td>
<td class="org-center">O(1)</td>
<td class="org-center">O(n)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-org523c54f" class="outline-2">
<h2 id="org523c54f">Implementing HashMap in C</h2>
<div class="outline-text-2" id="text-org523c54f">
<blockquote>
<p>
you can find the code for this blog post in <a href="https://github.com/ramajd/c_hashmap">this repository</a>. 
</p>
</blockquote>

<p>
in this post we want to implement a <code>HashMap</code> data structure, with <code>int</code> as the
keys and <code>void*</code> as values.
</p>

<p>
First step, we need to define the data structure that stores the <code>HashMap</code>
items. and also the functions for allocation and deletion operations. we call it
<code>MapEntry</code>.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #81A1C1;">typedef</span> <span style="color: #81A1C1;">struct</span> <span style="color: #8FBCBB;">_MapEntry</span> {
  <span style="color: #8FBCBB;">int</span> <span style="color: #D8DEE9;">key</span>;
  <span style="color: #8FBCBB;">void</span> *<span style="color: #D8DEE9;">value</span>;
  <span style="color: #81A1C1;">struct</span> <span style="color: #8FBCBB;">_MapEntry</span> *<span style="color: #D8DEE9;">next</span>;
} <span style="color: #8FBCBB;">MapEntry</span>;

<span style="color: #8FBCBB;">MapEntry</span> *<span style="color: #88C0D0;">map_entry_init</span>(<span style="color: #8FBCBB;">int</span> <span style="color: #D8DEE9;">key</span>, <span style="color: #8FBCBB;">void</span> *<span style="color: #D8DEE9;">value</span>);
<span style="color: #8FBCBB;">void</span> <span style="color: #88C0D0;">map_entry_free</span>(<span style="color: #8FBCBB;">MapEntry</span> *<span style="color: #D8DEE9;">entry</span>);
</pre>
</div>

<p>
the implementation for the allocation and deletion functions are
straight-forward:
</p>

<ul class="org-ul">
<li><p>
Allocate new <code>MapEntry</code>:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #8FBCBB;">MapEntry</span> *<span style="color: #88C0D0;">map_entry_init</span>(<span style="color: #8FBCBB;">int</span> <span style="color: #D8DEE9;">key</span>, <span style="color: #8FBCBB;">void</span> *<span style="color: #D8DEE9;">value</span>) {
  <span style="color: #8FBCBB;">MapEntry</span> *<span style="color: #D8DEE9;">entry</span> = malloc(<span style="color: #81A1C1;">sizeof</span>(MapEntry));
  entry-&gt;key = key;
  entry-&gt;value = value;
  entry-&gt;next = <span style="color: #81A1C1;">NULL</span>;
  <span style="color: #81A1C1;">return</span> entry;
}
</pre>
</div></li>

<li><p>
Free the memory allocated for <code>MapEntry</code>: we should free the memory
recursively. for a <code>MapEntry</code> and all it's children.
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #8FBCBB;">void</span> <span style="color: #88C0D0;">map_entry_free</span>(<span style="color: #8FBCBB;">MapEntry</span> *<span style="color: #D8DEE9;">entry</span>) {
  <span style="color: #81A1C1;">while</span> (entry &amp;&amp; entry-&gt;next) {
    map_entry_free(entry-&gt;next);
  }
  free(entry);
}
</pre>
</div></li>
</ul>

<p>
Having the <code>MapEntry</code> structure, now we can go implementing the <code>HashMap</code>
itself.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #81A1C1;">typedef</span> <span style="color: #81A1C1;">struct</span> {
  <span style="color: #8FBCBB;">MapEntry</span> **<span style="color: #D8DEE9;">entries</span>;
  <span style="color: #8FBCBB;">size_t</span> <span style="color: #D8DEE9;">count</span>;
  <span style="color: #8FBCBB;">size_t</span> <span style="color: #D8DEE9;">size</span>;
} <span style="color: #8FBCBB;">HashMap</span>;

<span style="color: #8FBCBB;">HashMap</span> *<span style="color: #88C0D0;">hash_map_init</span>(<span style="color: #8FBCBB;">size_t</span> <span style="color: #D8DEE9;">map_size</span>);
<span style="color: #8FBCBB;">void</span> <span style="color: #88C0D0;">hash_map_free</span>(<span style="color: #8FBCBB;">HashMap</span> *<span style="color: #D8DEE9;">map</span>);
<span style="color: #8FBCBB;">void</span> <span style="color: #88C0D0;">hash_map_insert</span>(<span style="color: #8FBCBB;">HashMap</span> *<span style="color: #D8DEE9;">map</span>, <span style="color: #8FBCBB;">int</span> <span style="color: #D8DEE9;">key</span>, <span style="color: #8FBCBB;">void</span> *<span style="color: #D8DEE9;">value</span>);
<span style="color: #8FBCBB;">bool</span> <span style="color: #88C0D0;">hash_map_get</span>(<span style="color: #8FBCBB;">HashMap</span> *<span style="color: #D8DEE9;">map</span>, <span style="color: #8FBCBB;">int</span> <span style="color: #D8DEE9;">key</span>, <span style="color: #8FBCBB;">void</span> *<span style="color: #D8DEE9;">value</span>);
<span style="color: #8FBCBB;">void</span> *<span style="color: #88C0D0;">hash_map_delete</span>(<span style="color: #8FBCBB;">HashMap</span> *<span style="color: #D8DEE9;">map</span>, <span style="color: #8FBCBB;">int</span> <span style="color: #D8DEE9;">key</span>);
</pre>
</div>

<ul class="org-ul">
<li><p>
Initiate new <code>HashMap</code>: first we allocate the memory itself. then we need to
allocate the memory for it's entries.
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #8FBCBB;">HashMap</span> *<span style="color: #88C0D0;">hash_map_init</span>(<span style="color: #8FBCBB;">size_t</span> <span style="color: #D8DEE9;">map_size</span>) {
  <span style="color: #8FBCBB;">HashMap</span> *<span style="color: #D8DEE9;">map</span> = malloc(<span style="color: #81A1C1;">sizeof</span>(map_size));
  map-&gt;count = 0;
  map-&gt;size = map_size;
  map-&gt;entries = malloc(<span style="color: #81A1C1;">sizeof</span>(MapEntry) * map_size);
  <span style="color: #8FBCBB;">size_t</span> <span style="color: #D8DEE9;">i</span>;
  <span style="color: #81A1C1;">for</span> (i = 0; i &lt; map_size; ++i) {
    map-&gt;entries[i] = <span style="color: #81A1C1;">NULL</span>;
  }
  <span style="color: #81A1C1;">return</span> map;
}
</pre>
</div></li>

<li><p>
Free an allocated <code>HashMap</code>: first we need to free the map entries
recursively. then we delete the <code>HashMap</code> itself from memory.
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #8FBCBB;">void</span> <span style="color: #88C0D0;">hash_map_free</span>(<span style="color: #8FBCBB;">HashMap</span> *<span style="color: #D8DEE9;">map</span>) {
  <span style="color: #8FBCBB;">size_t</span> <span style="color: #D8DEE9;">i</span>;
  <span style="color: #81A1C1;">for</span> (i = 0; i &lt; map-&gt;size; ++i) {
    map_entry_free(map-&gt;entries[i]);
    map-&gt;entries[i] = <span style="color: #81A1C1;">NULL</span>;
  }
  free(map);
}
</pre>
</div></li>

<li><p>
Hash function: we need to define a function to transform each key to a
position in <code>HashMap</code>. for simplicity we use the reminder of the  <code>key</code>
divided by map size as the item position.
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #8FBCBB;">size_t</span> <span style="color: #88C0D0;">hash_function</span>(<span style="color: #8FBCBB;">HashMap</span> *<span style="color: #D8DEE9;">map</span>, <span style="color: #8FBCBB;">int</span> <span style="color: #D8DEE9;">key</span>) {
  <span style="color: #81A1C1;">return</span> key % map-&gt;size;
}
</pre>
</div></li>

<li><p>
Insert new value: first we need to calculate the key slot using our hash
function, then we will put the <code>MapEntry</code> to matching slot. in case of
colision occurence, we should add the entry to the end of the slot
linked-list.
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #8FBCBB;">void</span> <span style="color: #88C0D0;">hash_map_insert</span>(<span style="color: #8FBCBB;">HashMap</span> *<span style="color: #D8DEE9;">map</span>, <span style="color: #8FBCBB;">int</span> <span style="color: #D8DEE9;">key</span>, <span style="color: #8FBCBB;">void</span> *<span style="color: #D8DEE9;">value</span>){
  <span style="color: #8FBCBB;">MapEntry</span> *<span style="color: #D8DEE9;">entry</span> = map_entry_init(key, value);
  <span style="color: #8FBCBB;">size_t</span> <span style="color: #D8DEE9;">slot</span> = hash_function(map, key);
  <span style="color: #81A1C1;">if</span> (map-&gt;entries[slot] == <span style="color: #81A1C1;">NULL</span>) {
    map-&gt;entries[slot] = entry;
  } <span style="color: #81A1C1;">else</span> {
    <span style="color: #8FBCBB;">MapEntry</span> *<span style="color: #D8DEE9;">iter</span> = map-&gt;entries[slot];
    <span style="color: #81A1C1;">while</span> (iter-&gt;next) {
      iter = iter-&gt;next;
    }
    iter-&gt;next = entry;
  }
  map-&gt;count += 1;
}
</pre>
</div></li>

<li><p>
Get value for a key: to get the matching value for for a key, first we check
the matching slot in map, if the key not found, we traverse the linked-list.
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #8FBCBB;">bool</span> <span style="color: #88C0D0;">hash_map_get</span>(<span style="color: #8FBCBB;">HashMap</span> *<span style="color: #D8DEE9;">map</span>, <span style="color: #8FBCBB;">int</span> <span style="color: #D8DEE9;">key</span>, <span style="color: #8FBCBB;">void</span> *<span style="color: #D8DEE9;">value</span>) {
  <span style="color: #8FBCBB;">size_t</span> <span style="color: #D8DEE9;">slot</span> = hash_function(map, key);
  <span style="color: #8FBCBB;">MapEntry</span> *<span style="color: #D8DEE9;">iter</span> = map-&gt;entries[slot];
  <span style="color: #81A1C1;">while</span> (iter) {
    <span style="color: #81A1C1;">if</span> (iter-&gt;key == key) {
      value = iter-&gt;value;
      <span style="color: #81A1C1;">return</span> <span style="color: #81A1C1;">true</span>;
    }
    iter = iter-&gt;next;
  }
  <span style="color: #81A1C1;">return</span> <span style="color: #81A1C1;">false</span>;
}
</pre>
</div></li>

<li><p>
delete entry: similar to the <code>has_map_get</code> function, we need to search for the
matching key's position. then we should remove the entry, and update the
pointers for the matching entry, and it's parent entry.
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #8FBCBB;">void</span> *<span style="color: #88C0D0;">hash_map_delete</span>(<span style="color: #8FBCBB;">HashMap</span> *<span style="color: #D8DEE9;">map</span>, <span style="color: #8FBCBB;">int</span> <span style="color: #D8DEE9;">key</span>) {
  <span style="color: #8FBCBB;">size_t</span> <span style="color: #D8DEE9;">slot</span> = hash_function(map, key);
  <span style="color: #8FBCBB;">MapEntry</span> *<span style="color: #D8DEE9;">iter</span> = map-&gt;entries[slot];
  <span style="color: #8FBCBB;">MapEntry</span> *<span style="color: #D8DEE9;">prv</span> = <span style="color: #81A1C1;">NULL</span>;
  <span style="color: #81A1C1;">while</span> (iter) {
    <span style="color: #81A1C1;">if</span> (iter-&gt;key == key) {
      <span style="color: #81A1C1;">if</span> (<span style="color: #81A1C1;">!</span>prv) {
        map-&gt;entries[slot] = iter-&gt;next;
      } <span style="color: #81A1C1;">else</span> {
        prv-&gt;next = iter-&gt;next;
      }
      iter-&gt;next = <span style="color: #81A1C1;">NULL</span>;
      <span style="color: #8FBCBB;">void</span> *<span style="color: #D8DEE9;">value</span> = iter-&gt;value;
      map_entry_free(iter);
      map-&gt;count -= 1;
      <span style="color: #81A1C1;">return</span> value;
    }
    prv = iter;
    iter = iter-&gt;next;
  }
  <span style="color: #81A1C1;">return</span> <span style="color: #81A1C1;">NULL</span>;
}
</pre>
</div></li>
</ul>
</div>
</div>
<div class="taglist"><a href="https://ramajd.github.io/tags.html">Tags</a>: <a href="https://ramajd.github.io/tag-programming.html">programming</a> <a href="https://ramajd.github.io/tag-c.html">c</a> <a href="https://ramajd.github.io/tag-hash-map.html">hash-map</a> </div><div id="archive">
<a href="https://ramajd.github.io/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status">
<center>
  <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/">
    <img alt="Creative Commons License" 
         style="border-width:0" 
         src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
  <br />
  licensed under a 
  <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/">
    Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.
</center></div>
</body>
</html>
